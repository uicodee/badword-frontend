/**
 * Generated by orval v6.25.0 üç∫
 * Do not edit manually.
 * FastAPI
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query'
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query'
import type {
  AppApiSchemsWordWord,
  AppDtoWordWord,
  DeleteWordWordDeleteDelete200,
  DeleteWordWordDeleteDeleteParams,
  GetWordsWordAllGetParams,
  HTTPValidationError,
  PaginatedWord,
  UpdateWord
} from '.././model'
import { createInstance } from '.././http/index';
import type { ErrorType, BodyType } from '.././http/index';


type SecondParameter<T extends (...args: any) => any> = Parameters<T>[1];


/**
 * Get all words
 * @summary Get all words in JSON format
 */
export const getAllWordsWordJsonGet = (
    
 options?: SecondParameter<typeof createInstance>,signal?: AbortSignal
) => {
      
      
      return createInstance<AppDtoWordWord[]>(
      {url: `http://localhost:15400/word/json`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAllWordsWordJsonGetQueryKey = () => {
    return [`http://localhost:15400/word/json`] as const;
    }

    
export const getGetAllWordsWordJsonGetQueryOptions = <TData = Awaited<ReturnType<typeof getAllWordsWordJsonGet>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllWordsWordJsonGet>>, TError, TData>>, request?: SecondParameter<typeof createInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllWordsWordJsonGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllWordsWordJsonGet>>> = ({ signal }) => getAllWordsWordJsonGet(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllWordsWordJsonGet>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAllWordsWordJsonGetQueryResult = NonNullable<Awaited<ReturnType<typeof getAllWordsWordJsonGet>>>
export type GetAllWordsWordJsonGetQueryError = ErrorType<unknown>

/**
 * @summary Get all words in JSON format
 */
export const useGetAllWordsWordJsonGet = <TData = Awaited<ReturnType<typeof getAllWordsWordJsonGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllWordsWordJsonGet>>, TError, TData>>, request?: SecondParameter<typeof createInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAllWordsWordJsonGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Get all words
 * @summary Get all words by page, limit and type
 */
export const getWordsWordAllGet = (
    params?: GetWordsWordAllGetParams,
 options?: SecondParameter<typeof createInstance>,signal?: AbortSignal
) => {
      
      
      return createInstance<PaginatedWord>(
      {url: `http://localhost:15400/word/all`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetWordsWordAllGetQueryKey = (params?: GetWordsWordAllGetParams,) => {
    return [`http://localhost:15400/word/all`, ...(params ? [params]: [])] as const;
    }

    
export const getGetWordsWordAllGetQueryOptions = <TData = Awaited<ReturnType<typeof getWordsWordAllGet>>, TError = ErrorType<HTTPValidationError>>(params?: GetWordsWordAllGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWordsWordAllGet>>, TError, TData>>, request?: SecondParameter<typeof createInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWordsWordAllGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWordsWordAllGet>>> = ({ signal }) => getWordsWordAllGet(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWordsWordAllGet>>, TError, TData> & { queryKey: QueryKey }
}

export type GetWordsWordAllGetQueryResult = NonNullable<Awaited<ReturnType<typeof getWordsWordAllGet>>>
export type GetWordsWordAllGetQueryError = ErrorType<HTTPValidationError>

/**
 * @summary Get all words by page, limit and type
 */
export const useGetWordsWordAllGet = <TData = Awaited<ReturnType<typeof getWordsWordAllGet>>, TError = ErrorType<HTTPValidationError>>(
 params?: GetWordsWordAllGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWordsWordAllGet>>, TError, TData>>, request?: SecondParameter<typeof createInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetWordsWordAllGetQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Get word by word
 * @summary Get word by word
 */
export const getWordWordWordGet = (
    word: string,
 options?: SecondParameter<typeof createInstance>,signal?: AbortSignal
) => {
      
      
      return createInstance<AppDtoWordWord>(
      {url: `http://localhost:15400/word/${word}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetWordWordWordGetQueryKey = (word: string,) => {
    return [`http://localhost:15400/word/${word}`] as const;
    }

    
export const getGetWordWordWordGetQueryOptions = <TData = Awaited<ReturnType<typeof getWordWordWordGet>>, TError = ErrorType<HTTPValidationError>>(word: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWordWordWordGet>>, TError, TData>>, request?: SecondParameter<typeof createInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWordWordWordGetQueryKey(word);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWordWordWordGet>>> = ({ signal }) => getWordWordWordGet(word, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(word), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWordWordWordGet>>, TError, TData> & { queryKey: QueryKey }
}

export type GetWordWordWordGetQueryResult = NonNullable<Awaited<ReturnType<typeof getWordWordWordGet>>>
export type GetWordWordWordGetQueryError = ErrorType<HTTPValidationError>

/**
 * @summary Get word by word
 */
export const useGetWordWordWordGet = <TData = Awaited<ReturnType<typeof getWordWordWordGet>>, TError = ErrorType<HTTPValidationError>>(
 word: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWordWordWordGet>>, TError, TData>>, request?: SecondParameter<typeof createInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetWordWordWordGetQueryOptions(word,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Add word
 * @summary Add new word
 */
export const addWordWordNewPost = (
    appApiSchemsWordWord: BodyType<AppApiSchemsWordWord>,
 options?: SecondParameter<typeof createInstance>,) => {
      
      
      return createInstance<AppDtoWordWord>(
      {url: `http://localhost:15400/word/new`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: appApiSchemsWordWord
    },
      options);
    }
  


export const getAddWordWordNewPostMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addWordWordNewPost>>, TError,{data: BodyType<AppApiSchemsWordWord>}, TContext>, request?: SecondParameter<typeof createInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof addWordWordNewPost>>, TError,{data: BodyType<AppApiSchemsWordWord>}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addWordWordNewPost>>, {data: BodyType<AppApiSchemsWordWord>}> = (props) => {
          const {data} = props ?? {};

          return  addWordWordNewPost(data,requestOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type AddWordWordNewPostMutationResult = NonNullable<Awaited<ReturnType<typeof addWordWordNewPost>>>
    export type AddWordWordNewPostMutationBody = BodyType<AppApiSchemsWordWord>
    export type AddWordWordNewPostMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Add new word
 */
export const useAddWordWordNewPost = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addWordWordNewPost>>, TError,{data: BodyType<AppApiSchemsWordWord>}, TContext>, request?: SecondParameter<typeof createInstance>}
) => {

      const mutationOptions = getAddWordWordNewPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Set word checked or unchecked
 * @summary Set word checked or unchecked status
 */
export const setCheckedWordSetCheckedPut = (
    updateWord: BodyType<UpdateWord>,
 options?: SecondParameter<typeof createInstance>,) => {
      
      
      return createInstance<AppDtoWordWord>(
      {url: `http://localhost:15400/word/set-checked`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateWord
    },
      options);
    }
  


export const getSetCheckedWordSetCheckedPutMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof setCheckedWordSetCheckedPut>>, TError,{data: BodyType<UpdateWord>}, TContext>, request?: SecondParameter<typeof createInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof setCheckedWordSetCheckedPut>>, TError,{data: BodyType<UpdateWord>}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof setCheckedWordSetCheckedPut>>, {data: BodyType<UpdateWord>}> = (props) => {
          const {data} = props ?? {};

          return  setCheckedWordSetCheckedPut(data,requestOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type SetCheckedWordSetCheckedPutMutationResult = NonNullable<Awaited<ReturnType<typeof setCheckedWordSetCheckedPut>>>
    export type SetCheckedWordSetCheckedPutMutationBody = BodyType<UpdateWord>
    export type SetCheckedWordSetCheckedPutMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Set word checked or unchecked status
 */
export const useSetCheckedWordSetCheckedPut = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof setCheckedWordSetCheckedPut>>, TError,{data: BodyType<UpdateWord>}, TContext>, request?: SecondParameter<typeof createInstance>}
) => {

      const mutationOptions = getSetCheckedWordSetCheckedPutMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Delete word
 * @summary Delete word by word id
 */
export const deleteWordWordDeleteDelete = (
    params: DeleteWordWordDeleteDeleteParams,
 options?: SecondParameter<typeof createInstance>,) => {
      
      
      return createInstance<DeleteWordWordDeleteDelete200>(
      {url: `http://localhost:15400/word/delete`, method: 'DELETE',
        params
    },
      options);
    }
  


export const getDeleteWordWordDeleteDeleteMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteWordWordDeleteDelete>>, TError,{params: DeleteWordWordDeleteDeleteParams}, TContext>, request?: SecondParameter<typeof createInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteWordWordDeleteDelete>>, TError,{params: DeleteWordWordDeleteDeleteParams}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteWordWordDeleteDelete>>, {params: DeleteWordWordDeleteDeleteParams}> = (props) => {
          const {params} = props ?? {};

          return  deleteWordWordDeleteDelete(params,requestOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type DeleteWordWordDeleteDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteWordWordDeleteDelete>>>
    
    export type DeleteWordWordDeleteDeleteMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Delete word by word id
 */
export const useDeleteWordWordDeleteDelete = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteWordWordDeleteDelete>>, TError,{params: DeleteWordWordDeleteDeleteParams}, TContext>, request?: SecondParameter<typeof createInstance>}
) => {

      const mutationOptions = getDeleteWordWordDeleteDeleteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    