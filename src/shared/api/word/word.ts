/**
 * Generated by orval v6.25.0 üç∫
 * Do not edit manually.
 * Badword API
 * The badword API
 * OpenAPI spec version: 1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query'
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query'
import * as axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios'
import type {
  CreateWordDto,
  UpdateWordStatusDto,
  Word,
  WordControllerFindAllParams,
  WordControllerFindOneByWordParams,
  WordPageCountDto
} from '.././model'



export const wordControllerCreate = (
    createWordDto: CreateWordDto, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Word>> => {
    
    return axios.default.post(
      `http://localhost:3000/word`,
      createWordDto,options
    );
  }



export const getWordControllerCreateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof wordControllerCreate>>, TError,{data: CreateWordDto}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof wordControllerCreate>>, TError,{data: CreateWordDto}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof wordControllerCreate>>, {data: CreateWordDto}> = (props) => {
          const {data} = props ?? {};

          return  wordControllerCreate(data,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type WordControllerCreateMutationResult = NonNullable<Awaited<ReturnType<typeof wordControllerCreate>>>
    export type WordControllerCreateMutationBody = CreateWordDto
    export type WordControllerCreateMutationError = AxiosError<unknown>

    export const useWordControllerCreate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof wordControllerCreate>>, TError,{data: CreateWordDto}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getWordControllerCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    export const wordControllerFindAll = (
    params?: WordControllerFindAllParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Word[]>> => {
    
    return axios.default.get(
      `http://localhost:3000/word`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getWordControllerFindAllQueryKey = (params?: WordControllerFindAllParams,) => {
    return [`http://localhost:3000/word`, ...(params ? [params]: [])] as const;
    }

    
export const getWordControllerFindAllQueryOptions = <TData = Awaited<ReturnType<typeof wordControllerFindAll>>, TError = AxiosError<unknown>>(params?: WordControllerFindAllParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof wordControllerFindAll>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getWordControllerFindAllQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof wordControllerFindAll>>> = ({ signal }) => wordControllerFindAll(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof wordControllerFindAll>>, TError, TData> & { queryKey: QueryKey }
}

export type WordControllerFindAllQueryResult = NonNullable<Awaited<ReturnType<typeof wordControllerFindAll>>>
export type WordControllerFindAllQueryError = AxiosError<unknown>

export const useWordControllerFindAll = <TData = Awaited<ReturnType<typeof wordControllerFindAll>>, TError = AxiosError<unknown>>(
 params?: WordControllerFindAllParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof wordControllerFindAll>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getWordControllerFindAllQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const wordControllerGetWordPages = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<WordPageCountDto>> => {
    
    return axios.default.get(
      `http://localhost:3000/word/count`,options
    );
  }


export const getWordControllerGetWordPagesQueryKey = () => {
    return [`http://localhost:3000/word/count`] as const;
    }

    
export const getWordControllerGetWordPagesQueryOptions = <TData = Awaited<ReturnType<typeof wordControllerGetWordPages>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof wordControllerGetWordPages>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getWordControllerGetWordPagesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof wordControllerGetWordPages>>> = ({ signal }) => wordControllerGetWordPages({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof wordControllerGetWordPages>>, TError, TData> & { queryKey: QueryKey }
}

export type WordControllerGetWordPagesQueryResult = NonNullable<Awaited<ReturnType<typeof wordControllerGetWordPages>>>
export type WordControllerGetWordPagesQueryError = AxiosError<unknown>

export const useWordControllerGetWordPages = <TData = Awaited<ReturnType<typeof wordControllerGetWordPages>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof wordControllerGetWordPages>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getWordControllerGetWordPagesQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const wordControllerGetJsonFile = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.default.get(
      `http://localhost:3000/word/json`,options
    );
  }


export const getWordControllerGetJsonFileQueryKey = () => {
    return [`http://localhost:3000/word/json`] as const;
    }

    
export const getWordControllerGetJsonFileQueryOptions = <TData = Awaited<ReturnType<typeof wordControllerGetJsonFile>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof wordControllerGetJsonFile>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getWordControllerGetJsonFileQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof wordControllerGetJsonFile>>> = ({ signal }) => wordControllerGetJsonFile({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof wordControllerGetJsonFile>>, TError, TData> & { queryKey: QueryKey }
}

export type WordControllerGetJsonFileQueryResult = NonNullable<Awaited<ReturnType<typeof wordControllerGetJsonFile>>>
export type WordControllerGetJsonFileQueryError = AxiosError<unknown>

export const useWordControllerGetJsonFile = <TData = Awaited<ReturnType<typeof wordControllerGetJsonFile>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof wordControllerGetJsonFile>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getWordControllerGetJsonFileQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const wordControllerFindOneByWord = (
    params: WordControllerFindOneByWordParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Word>> => {
    
    return axios.default.get(
      `http://localhost:3000/word/find`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getWordControllerFindOneByWordQueryKey = (params: WordControllerFindOneByWordParams,) => {
    return [`http://localhost:3000/word/find`, ...(params ? [params]: [])] as const;
    }

    
export const getWordControllerFindOneByWordQueryOptions = <TData = Awaited<ReturnType<typeof wordControllerFindOneByWord>>, TError = AxiosError<unknown>>(params: WordControllerFindOneByWordParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof wordControllerFindOneByWord>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getWordControllerFindOneByWordQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof wordControllerFindOneByWord>>> = ({ signal }) => wordControllerFindOneByWord(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof wordControllerFindOneByWord>>, TError, TData> & { queryKey: QueryKey }
}

export type WordControllerFindOneByWordQueryResult = NonNullable<Awaited<ReturnType<typeof wordControllerFindOneByWord>>>
export type WordControllerFindOneByWordQueryError = AxiosError<unknown>

export const useWordControllerFindOneByWord = <TData = Awaited<ReturnType<typeof wordControllerFindOneByWord>>, TError = AxiosError<unknown>>(
 params: WordControllerFindOneByWordParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof wordControllerFindOneByWord>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getWordControllerFindOneByWordQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const wordControllerFindOne = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Word>> => {
    
    return axios.default.get(
      `http://localhost:3000/word/${id}`,options
    );
  }


export const getWordControllerFindOneQueryKey = (id: string,) => {
    return [`http://localhost:3000/word/${id}`] as const;
    }

    
export const getWordControllerFindOneQueryOptions = <TData = Awaited<ReturnType<typeof wordControllerFindOne>>, TError = AxiosError<unknown>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof wordControllerFindOne>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getWordControllerFindOneQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof wordControllerFindOne>>> = ({ signal }) => wordControllerFindOne(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof wordControllerFindOne>>, TError, TData> & { queryKey: QueryKey }
}

export type WordControllerFindOneQueryResult = NonNullable<Awaited<ReturnType<typeof wordControllerFindOne>>>
export type WordControllerFindOneQueryError = AxiosError<unknown>

export const useWordControllerFindOne = <TData = Awaited<ReturnType<typeof wordControllerFindOne>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof wordControllerFindOne>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getWordControllerFindOneQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const wordControllerUpdate = (
    id: string,
    updateWordStatusDto: UpdateWordStatusDto, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.default.patch(
      `http://localhost:3000/word/${id}`,
      updateWordStatusDto,options
    );
  }



export const getWordControllerUpdateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof wordControllerUpdate>>, TError,{id: string;data: UpdateWordStatusDto}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof wordControllerUpdate>>, TError,{id: string;data: UpdateWordStatusDto}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof wordControllerUpdate>>, {id: string;data: UpdateWordStatusDto}> = (props) => {
          const {id,data} = props ?? {};

          return  wordControllerUpdate(id,data,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type WordControllerUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof wordControllerUpdate>>>
    export type WordControllerUpdateMutationBody = UpdateWordStatusDto
    export type WordControllerUpdateMutationError = AxiosError<unknown>

    export const useWordControllerUpdate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof wordControllerUpdate>>, TError,{id: string;data: UpdateWordStatusDto}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getWordControllerUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    export const wordControllerRemove = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.default.delete(
      `http://localhost:3000/word/${id}`,options
    );
  }



export const getWordControllerRemoveMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof wordControllerRemove>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof wordControllerRemove>>, TError,{id: string}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof wordControllerRemove>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  wordControllerRemove(id,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type WordControllerRemoveMutationResult = NonNullable<Awaited<ReturnType<typeof wordControllerRemove>>>
    
    export type WordControllerRemoveMutationError = AxiosError<unknown>

    export const useWordControllerRemove = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof wordControllerRemove>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getWordControllerRemoveMutationOptions(options);

      return useMutation(mutationOptions);
    }
    